#!/usr/bin/env perl
use 5.008004;
use strict;
use warnings;
use App::ordo;
use JSON           qw(decode_json);
use File::ShareDir qw(dist_file);
use File::Spec;
use File::Copy qw(copy);
use File::Path qw(make_path);
use File::Basename qw(dirname);

use Term::ReadLine::Perl5;
use Mojo::UserAgent;
use Data::Dumper;
use Getopt::Long qw(GetOptionsFromString);
use JSON;
use DateTime::TimeZone;
use Email::Valid;
use IO::Socket::INET;
use Term::ReadKey;

use feature qw(say);

# Check internet connection
my $socket = IO::Socket::INET->new(
   PeerAddr => '8.8.8.8',
   PeerPort => 53,
   Proto    => 'tcp',
   Timeout  => 5
);

unless ($socket) {
   print "No internet connection\n";
   exit;
}

$socket->close();

# User-specific config file
my $user_config_dir = File::Spec->catdir($ENV{HOME}, '.config', 'App-ordo');
my $user_config_file = File::Spec->catfile($user_config_dir, 'ordo_config.json');

# Default config file from share directory
my $default_config_file = dist_file('App-ordo', 'ordo_config.json');

# Create user config directory and copy default config if it doesn't exist
unless (-e $user_config_file) {
    make_path($user_config_dir) unless -d $user_config_dir;
    copy($default_config_file, $user_config_file) or die "Cannot copy config to $user_config_file: $!";
    chmod 0644, $user_config_file;  # Ensure user-writable (rw-r--r--)
}

# Read config file
open my $fh, '<', $user_config_file or die "Cannot open config file $user_config_file: $!";
my $config_data = do { local $/; <$fh> };
close $fh;
my $config = decode_json($config_data);

my $token   = $config->{token};
my $aliases = $config->{aliases};
my $api     = $config->{api};
my ($host, $cluster);

my $ua   = Mojo::UserAgent->new(
   ssl_opts => {

      #ca => ['/etc/nginx/ssl/nginx-selfsigned.crt'],
      #ca => ['/etc/nginx/ssl/dhparam.pem'],
      #insecure => 1
   }
);
$ua->inactivity_timeout(10);
$ua->max_redirects(0)->connect_timeout(4)->request_timeout(5);

print "\nWelcome to the ordo job scheduler!\n";
my $login = &request("login user");

if ( $login->{success} ) {
   if ( $login->{level} == 0 ) {
      say "Already registered. Please check your email to confirm";
      exit;
   }
   &request("find cluster");
}
else {

   # register as a new user
   my $email;
   print "Registration not found.\n";
   do {
      print "Please enter a valid email address: ";
      chomp($email = <STDIN>);
   } while (!Email::Valid->address( -address => $email, -mxcheck => 1));

   my $register = &request("register user -email $email");
   say $register->{message};
   exit;
}

# main loop
my $term = Term::ReadLine::Perl5->new('ordo');
while ( defined( my $line = $term->readline("$host:/$cluster> ") ) ) {
   next unless $line;
   print "\n";
   my $json = &request($line);

   #print to_json( $json, { pretty => 1 } );

   my $success = $json->{success} ? 'successful' : 'failed';
   print "Command $success. ";
   print ucfirst("$json->{message}") if $json->{message};
   print "\n\n";
}

sub write_config {
   my $config = shift;
   eval {
      open( my $fh, ">", $user_config_file ) or die "Cannot write to config file $user_config_file: $!";
      print $fh to_json( $config, { pretty => 1 } );
      close $fh;
   };
   return $@ ? 0 : 1;
}

sub request {
   my $line    = shift;
   my $command = &string2hash($line);
      
   return $command if defined $command->{success} && $command->{success} == 0;
   &before_dispatch( $command->{command}, $command );

   my $json = &send_request($command);
   
   &after_dispatch( $json->{command_reply}, $json );

   return $json;
}  

sub send_request {
   my $request = shift;
   my $json;
   eval { $json = $ua->get( $api => { Accept => 'application/json' } => json => $request )->result->json; };
   return $@ ? { success => 0, message => $@ } : $json;
}

sub after_dispatch {
   my ( $command, $json ) = @_;
   return unless $command && $json;

   my %dispatch = (
      change_cluster => \&change_cluster,
      login_user     => \&login_user,
      register_user  => \&new_token,
      find_cluster   => \&find_cluster,
      read_job       => \&print_table,
      read_cluster   => \&print_table,
      read_path      => \&print_table,
      find_cal       => \&find_cal,
      read_cal       => \&find_cal,
      find_log       => \&find_log,
      read_log       => \&read_log,
      read_monitor   => \&print_table,
      find_monitor   => \&find_monitor,
      create_monitor => \&create_monitor,
      new_token => \&new_token,
      read_user => \&_print_table,
      help_commands => \&help,
   );

   if ( exists( $dispatch{$command} ) ) {
      &{ $dispatch{$command} }($json);
      return 1;
   }
   else {
      return 0;
   }
}

sub before_dispatch {
   my ( $command, $json ) = @_;

   my %dispatch = ();

   if ( exists( $dispatch{$command} ) ) {
      &{ $dispatch{$command} }($json);
      return 1;
   }
   else {
      return 0;
   }
}

sub change_cluster {
   my $json = shift;
   if ( $json && $json->{success} ) {
      $cluster = $json->{path};
   }
}

sub login_user {
   my $json = shift;
   return unless $json && $json->{success};
   $host    = $json->{host} || '';
   $cluster = $json->{path} || '';
}

sub new_token {
   my $json = shift;

   return unless $json && $json->{token};

   $config->{token} = $json->{token};
   $token = $json->{token};

   my $success = &write_config($config);

   if ($success) {
      say "Using token $json->{token}";
   }
}

sub string2hash {
   my $string = shift;
   my %options;

   my ($cmds) = $string =~ /(.*?)(-.*)?$/;
   my ($opts) = $string =~ /(-.*$)/;
   my ( $verb, $noun, $name ) = &extract_command($cmds);

   if ($opts) {

      my ( $ret, $args ) = GetOptionsFromString(
         $opts,         \%options,  "command=s",   "token=s",      "state:s",  "user:s",   "host:s",       "newname:s", "password:s", "script:s",
         "email:s",     "level:i",  "cron:s",      "at:s",         "cal:s",    "cal_id:i", "force",        "count:i",   "needs:i@",   "description:s",
         "server_id:i", "name:s",   "job_id:i",    "cluster_id:i", "server:s", "org_id:i", "pid:i",        "id:s",      "match:s",    "tz:s",
         "begin:s",     "expire:s", "parent_id:i", "retrys:i",     "delay:i",  "loops:i",  "fail_alarm:i", "mode:i",    "clonable:i",   "log:i",
         "json:s", "needs_any:i"
      );

      # allow multi-value needs

      if ( $opts =~ /needs\s+/ ) {
         my @needs;
         $opts =~ s/^.*?(-needs.*$)/$1/;
         $opts =~ s/(.*?needs[^-]*?)-.*/$1/;
         GetOptionsFromString( $opts, 'needs:i{,}' => \@needs );
         $options{needs} = \@needs if scalar @needs && scalar @needs > scalar @{ $options{needs} };
      }
   }

   my $cmd;

   if ( exists $aliases->{$verb} ) {
      $cmd  = $aliases->{$verb};
      $name = $noun;
   }
   else {
      $cmd = $noun ? join( '_', ( $verb, $noun ) ) : $verb;
   }

   return { success => 0, message => 'command not found' } unless $cmd;

   # convert dates to epoch seconds
   foreach my $o (qw(at begin expire)) {
      if ( $options{$o} ) {
         my $seconds = &date_to_epoch( $options{$o} );
         if ($seconds) {
            $options{$o} = $seconds;
         }
         else {
            delete $options{$o};
         }
      }
   }

   $options{tz} ||= $App::ordo::tz;    # time zone needed for crontab
   my $res = { token => $token, command => $cmd, %options };
   $res->{name} = $name if defined $name;
   return $res;
}

