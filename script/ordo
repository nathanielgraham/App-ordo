#!/usr/bin/env perl
use 5.008004;
use strict;
use warnings;
use App::ordo;
use JSON           qw(decode_json);
use File::ShareDir qw(dist_file);
use File::Spec;
use File::Copy qw(copy);
use File::Path qw(make_path);
use File::Basename qw(dirname);

use Term::ReadLine::Perl5;
use Mojo::UserAgent;
use Data::Dumper;
use Getopt::Long qw(GetOptionsFromString);
use JSON;
use DateTime::TimeZone;
use Email::Valid;
use IO::Socket::INET;
use Term::ReadKey;

use feature qw(say);

# Check internet connection
my $socket = IO::Socket::INET->new(
   PeerAddr => '8.8.8.8',
   PeerPort => 53,
   Proto    => 'tcp',
   Timeout  => 5
);

unless ($socket) {
   print "No internet connection\n";
   exit;
}

$socket->close();

# User-specific config file
my $user_config_dir = File::Spec->catdir($ENV{HOME}, '.config', 'App-ordo');
my $user_config_file = File::Spec->catfile($user_config_dir, 'ordo_config.json');

# Default config file from share directory
my $default_config_file = dist_file('App-ordo', 'ordo_config.json');

# Create user config directory and copy default config if it doesn't exist
unless (-e $user_config_file) {
    make_path($user_config_dir) unless -d $user_config_dir;
    copy($default_config_file, $user_config_file) or die "Cannot copy config to $user_config_file: $!";
    chmod 0644, $user_config_file;  # Ensure user-writable (rw-r--r--)
}

# Read config file
open my $fh, '<', $user_config_file or die "Cannot open config file $user_config_file: $!";
my $config_data = do { local $/; <$fh> };
close $fh;
my $config = decode_json($config_data);

my $token   = $config->{token};
my $aliases = $config->{aliases};
my $api     = $config->{api};
my ($host, $cluster);
print Dumper($config);

my $ua   = Mojo::UserAgent->new(
   ssl_opts => {

      #ca => ['/etc/nginx/ssl/nginx-selfsigned.crt'],
      #ca => ['/etc/nginx/ssl/dhparam.pem'],
      #insecure => 1
   }
);
$ua->inactivity_timeout(10);
$ua->max_redirects(0)->connect_timeout(4)->request_timeout(5);

print "\nWelcome to the Ordo job scheduler!\n";
my $login = &request("login user");

if ( $login->{success} ) {
   if ( $login->{level} == 0 ) {
      say "Already registered. Please check your email to confirm";
      exit;
   }
   &request("find cluster");
}
else {

   # register as a new user
   my $email;
   do {
      print "Please enter a valid email address: ";
      chomp($email = <STDIN>);
   } while (!Email::Valid->address( -address => $email, -mxcheck => 1));

   my $register = &request("register user -email $email");
   say $register->{message};
   exit;
}

# main loop
my $term = Term::ReadLine::Perl5->new('ordo');
while ( defined( my $line = $term->readline("$host:/$cluster> ") ) ) {
   next unless $line;
   print "\n";
   my $json = &request($line);

   #print to_json( $json, { pretty => 1 } );

   my $success = $json->{success} ? 'successful' : 'failed';
   print "Command $success. ";
   print ucfirst("$json->{message}") if $json->{message};
   print "\n\n";
}

sub write_config {
   my $config = shift;
   eval {
      open( my $fh, ">", $user_config_file ) or die "Cannot write to config file $user_config_file: $!";
      print $fh to_json( $config, { pretty => 1 } );
      close $fh;
   };
   return $@ ? 0 : 1;
}

sub request {
   my $line    = shift;
   my $command = &string2hash($line);
      
   return $command if defined $command->{success} && $command->{success} == 0;
   &before_dispatch( $command->{command}, $command );

   my $json = &send_request($command);
   
   &after_dispatch( $json->{command_reply}, $json );

   return $json;
}  

sub send_request {
   my $request = shift;
   my $json;
   eval { $json = $ua->get( $api => { Accept => 'application/json' } => json => $request )->result->json; };
   return $@ ? { success => 0, message => $@ } : $json;
}

sub less {
   my $string = shift;
   my @lines  = split( /\n/, $string );
   $_ .= "\n" for @lines;
   push @lines, "\n";

   # Get terminal size
   my ( $term_width, $term_height ) = GetTerminalSize();
   $term_height -= 1;    # Reserve one line for status

   my $total_lines  = @lines;
   my $current_line = 0;

   # If file fits in one screen, print and exit
   if ( $total_lines <= $term_height ) {
      for my $i ( 0 .. $total_lines - 1 ) {
         print $lines[$i];
      }
      return;
   }

   # Enable raw mode for key reading
   ReadMode('cbreak');

   # Main loop for interactive paging
   while (1) {

      # Move to top for content
      print "\033[1;1H";

      # Display lines for the current page, ensuring last line is shown
      my $lines_to_show = $term_height;
      if ( $current_line + $term_height > $total_lines ) {
         $current_line  = $total_lines - $term_height if $total_lines >= $term_height;
         $current_line  = 0                           if $current_line < 0;
         $lines_to_show = $total_lines - $current_line;
      }
      for my $i ( $current_line .. $current_line + $lines_to_show - 1 ) {
         last if $i >= $total_lines;
         print "\033[K";    # Clear line
         print $lines[$i];
      }

      # Clear any remaining lines to prevent artifacts
      for my $i ( $lines_to_show + 1 .. $term_height ) {
         print "\033[$i;1H\033[K";    # Clear line
      }

      # Calculate percentage
      my $percent = ( $total_lines > 0 ) ? ceil( ( $current_line + $lines_to_show ) / $total_lines * 100 ) : 100;
      $percent = 100 if $percent > 100;

      # Move cursor to bottom and print status line
      my $bottom_line = $current_line + $lines_to_show;
      print "\033[$term_height;1H\033[K";    # Move to bottom, clear line
      print "\033[7m:(line $bottom_line of $total_lines, $percent%) [Press q to quit, space to page down, b to page up, j/down or k/up to scroll]\033[0m";

      # Read key with better arrow key handling
      my $key   = ReadKey(0);
      my $input = $key;

      # Handle arrow key escape sequences
      if ( $key eq "\033" ) {                # Escape sequence start
         $key = ReadKey(0);
         if ( $key eq '[' ) {                # Arrow key sequence
            $key   = ReadKey(0);
            $input = "\033[$key";            # Full escape sequence
         }
         else {
            $input = "\033$key";             # Handle other escape sequences
         }
      }

      # Handle key presses
      if ( $input eq 'q' ) {
         print "\033[$term_height;1H\033[K";    # Clear status line
         last;                                  # Quit
      }
      elsif ( $input eq ' ' ) {
         $current_line += $term_height;         # Page down
         $current_line = $total_lines - $term_height if $current_line > $total_lines - $term_height;
         $current_line = 0                           if $current_line < 0;
      }
      elsif ( $input eq 'b' ) {
         $current_line -= $term_height;         # Page up
         $current_line = 0 if $current_line < 0;
      }
      elsif ( $input eq 'j' || $input eq "\033[B" ) {    # j or down arrow
         $current_line += 1;                             # Scroll down one line
         $current_line = $total_lines - $term_height if $current_line > $total_lines - $term_height;
         $current_line = 0                           if $current_line < 0;
      }
      elsif ( $input eq 'k' || $input eq "\033[A" ) {    # k or up arrow
         $current_line -= 1;                             # Scroll up one line
         $current_line = 0 if $current_line < 0;
      }
   }

   # Restore terminal
   ReadMode('restore');
}

sub extract_command {
   my $string = shift;
   my @parts;
   my $current   = '';
   my $in_quotes = '';
   my $i         = 0;

   while ( $i < length($string) ) {
      my $char = substr( $string, $i, 1 );

      if ($in_quotes) {

         # Inside quotes, collect until matching quote
         $current .= $char;
         if ( $char eq $in_quotes && ( $i == 0 || substr( $string, $i - 1, 1 ) ne '\\' ) ) {
            $in_quotes = '';    # Exit quote mode
         }
      }
      elsif ( $char eq '"' || $char eq "'" ) {

         # Start of quoted string
         $in_quotes = $char;
         $current .= $char;
      }
      elsif ( $char =~ /\s/ ) {

         # Whitespace outside quotes: finalize current part
         if ( $current ne '' ) {
            push @parts, $current;
            $current = '';
         }
      }
      else {
         # Non-whitespace outside quotes
         $current .= $char;
      }
      $i++;
   }

   push @parts, $current if $current ne '';

   # Clean up quotes from the parts
   @parts = map { s/^['"]|['"]$//g; $_ } @parts;

   return @parts;
}

sub after_dispatch {
   my ( $command, $json ) = @_;
   return unless $command && $json;

   my %dispatch = (
      change_cluster => \&change_cluster,
      login_user     => \&login_user,
      register_user  => \&new_token,
      find_cluster   => \&find_cluster,
      read_job       => \&print_table,
      read_cluster   => \&print_table,
      read_path      => \&print_table,
      find_cal       => \&find_cal,
      read_cal       => \&find_cal,
      find_log       => \&find_log,
      read_log       => \&read_log,
      read_monitor   => \&print_table,
      find_monitor   => \&find_monitor,
      create_monitor => \&create_monitor,
      new_token => \&new_token,
      read_user => \&_print_table,
      help_commands => \&help,
   );

   if ( exists( $dispatch{$command} ) ) {
      &{ $dispatch{$command} }($json);
      return 1;
   }
   else {
      return 0;
   }
}

sub before_dispatch {
   my ( $command, $json ) = @_;

   my %dispatch = ();

   if ( exists( $dispatch{$command} ) ) {
      &{ $dispatch{$command} }($json);
      return 1;
   }
   else {
      return 0;
   }
}

sub change_cluster {
   my $json = shift;
   if ( $json && $json->{success} ) {
      $cluster = $json->{path};
   }
}

sub login_user {
   my $json = shift;
   return unless $json && $json->{success};
   $host    = $json->{host} || '';
   $cluster = $json->{path} || '';
}

sub new_token {
   my $json = shift;

   return unless $json && $json->{token};

   $config->{token} = $json->{token};
   $token = $json->{token};

   my $success = &write_config($config);

   if ($success) {
      say "Using token $json->{token}";
   }
}

sub string2hash {
   my $string = shift;
   my %options;

   my ($cmds) = $string =~ /(.*?)(-.*)?$/;
   my ($opts) = $string =~ /(-.*$)/;
   my ( $verb, $noun, $name ) = &extract_command($cmds);

   if ($opts) {

      my ( $ret, $args ) = GetOptionsFromString(
         $opts,         \%options,  "command=s",   "token=s",      "state:s",  "user:s",   "host:s",       "newname:s", "password:s", "script:s",
         "email:s",     "level:i",  "cron:s",      "at:s",         "cal:s",    "cal_id:i", "force",        "count:i",   "needs:i@",   "description:s",
         "server_id:i", "name:s",   "job_id:i",    "cluster_id:i", "server:s", "org_id:i", "pid:i",        "id:s",      "match:s",    "tz:s",
         "begin:s",     "expire:s", "parent_id:i", "retrys:i",     "delay:i",  "loops:i",  "fail_alarm:i", "mode:i",    "clonable:i",   "log:i",
         "json:s", "needs_any:i"
      );

      # allow multi-value needs

      if ( $opts =~ /needs\s+/ ) {
         my @needs;
         $opts =~ s/^.*?(-needs.*$)/$1/;
         $opts =~ s/(.*?needs[^-]*?)-.*/$1/;
         GetOptionsFromString( $opts, 'needs:i{,}' => \@needs );
         $options{needs} = \@needs if scalar @needs && scalar @needs > scalar @{ $options{needs} };
      }
   }

   my $cmd;

   if ( exists $aliases->{$verb} ) {
      $cmd  = $aliases->{$verb};
      $name = $noun;
   }
   else {
      $cmd = $noun ? join( '_', ( $verb, $noun ) ) : $verb;
   }

   #return { success => 0, message => 'command not found' } unless $noun && defined $verb;
   return { success => 0, message => 'command not found' } unless $cmd;

   # convert dates to epoch seconds
   foreach my $o (qw(at begin expire)) {
      if ( $options{$o} ) {
         my $seconds = &date_to_epoch( $options{$o} );
         if ($seconds) {
            $options{$o} = $seconds;
         }
         else {
            delete $options{$o};
         }
      }
   }

   $options{tz} ||= $App::ordo::tz;    # time zone needed for crontab
   my $res = { token => $token, command => $cmd, %options };
   $res->{name} = $name if defined $name;
   return $res;
}

